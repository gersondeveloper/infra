pipeline {
    agent any

    parameters {
        choice(name: 'PROJECT', choices: ['CCLD', 'CCLM', 'ALL'], description: 'Projeto para gerar release')
        string(name: 'NEW_VERSION', defaultValue: '1.2.1', description: 'Nova versão a ser gerada (ex: 1.2.1)')
    }

    environment {
        CCLD_REPOSITORY = 'https://github.com/gersondeveloper/ccld.git'
        CCLM_REPOSITORY = 'https://github.com/gersondeveloper/cclm.git'

        MAIN_BRANCH_CCLD = 'main'
        MAIN_BRANCH_CCLM = 'main'

        CCLD_CLOSED_VERSION = ''
        CCLM_CLOSED_VERSION = ''

        CHANGELOG_FILE = "CHANGELOG-${params.NEW_VERSION}.txt"
        START_TIME = ""
    }

    stages {
        stage('Init') {
            steps {
                script {
                    env.START_TIME = System.currentTimeMillis()
                    echo "\u001B[34m====================== Iniciando Pipeline de Release/Hotfix ======================\\u001B[0m"

                    sh '''
                        git config --global user.name "Roberto-Bot"
                        git config --global user.email "jenkins@gersondeveloper.com"
                    '''
                    echo "\u001B[32m✔️ Git identity set globally \u001B[0m"
                }
            }
        }


        stage('Clean Workspace') {
            steps {
                deleteDir()
                echo "\u001B[32m✔️ Workspace successfully cleaned \u001B[0m"
            }
        }

        stage('Fetch Code') {
            parallel {
                stage('Fetch CCLD') {
                    when { anyOf { expression { params.PROJECT == 'CCLD' }; expression { params.PROJECT == 'ALL' } } }
                    steps {
                        script {
                            echo "\u001B[34m=== Fetching CCLD Repository ===\u001B[0m"
                            checkout([$class: 'GitSCM', branches: [[name: "*/${env.MAIN_BRANCH_CCLD}"]], userRemoteConfigs: [[url: env.CCLD_REPOSITORY]]])
                            echo "\u001B[32m✔️ CCLD repository fetch concluído\u001B[0m"
                        }
                    }
                }
                stage('Fetch CCLM') {
                    when { anyOf { expression { params.PROJECT == 'CCLM' }; expression { params.PROJECT == 'ALL' } } }
                    steps {
                        script {
                            echo "\u001B[34m=== Fetching CCLM Repository ===\u001B[0m"
                            checkout([$class: 'GitSCM', branches: [[name: "*/${env.MAIN_BRANCH_CCLM}"]], userRemoteConfigs: [[url: env.CCLM_REPOSITORY]]])
                            echo "\u001B[32m✔️ CCLM repository fetch concluído\u001B[0m"
                        }
                    }
                }
            }
        }

        stage('Detectar Última Tag') {
            steps {
                script {
                    echo "\u001B[34m=== Detecting last tag ===\u001B[0m"
                    env.LAST_TAG = sh(
                        script: '''
                            git fetch --tags
                            git tag --sort=-creatordate | grep -E '^[0-9]+\\.[0-9]+\\.[0-9]+$' | head -n 1
                        ''',
                        returnStdout: true
                    ).trim()
                        echo "<span style='color:green'>✓ Last tag detected: ${env.LAST_TAG}</span>"
                }
            }
        }

        /* stage('Close Current Version') {
            steps {
                script {
                    echo "\u001B[34m=== Closing current version ===\u001B[0m"
                    if (params.PROJECT == 'CCLD' || params.PROJECT == 'ALL') {
                        closeCCLDVersion(params.NEW_VERSION)
                    }
                    if (params.PROJECT == 'CCLM' || params.PROJECT == 'ALL') {
                        closeCCLMVersion(params.NEW_VERSION, env.LAST_TAG)
                    }
                    echo "\u001B[32m✔️ Version closed successfully\u001B[0m"
                }
            }
        } */

        /* stage('Criar nova branch de release') {
            steps {
                script {
                    echo "\u001B[34m=== Avaliando necessidade de criação de branch de release ===\u001B[0m"
                    def tokens = params.NEW_VERSION.tokenize('.')
                    def patch = tokens[2].toInteger()
                    if (patch > 0) {
                        env.BRANCH_NAME = "release/${params.NEW_VERSION}"
                        sh "git checkout -b ${env.BRANCH_NAME}"
                        echo "\u001B[32m✔️ Branch ${env.BRANCH_NAME} criada\u001B[0m"
                    } else {
                        echo "\u001B[33m⚠️ Versão minor detectada. Branch de release não será criada.\u001B[0m"
                    }
                }
            }
        } */

        /* stage('Gerar Changelog e Cherry-pick se necessário') {
            steps {
                script {
                    echo "\u001B[34m=== Gerando changelog e realizando cherry-pick se necessário ===\u001B[0m"
                    def tokens = params.NEW_VERSION.tokenize('.')
                    def major = tokens[0].toInteger()
                    def minor = tokens[1].toInteger()
                    def patch = tokens[2].toInteger()
                    def commits = sh(
                        script: "git log ${env.LAST_TAG}..origin/${params.PROJECT == 'CCLM' ? env.MAIN_BRANCH_CCLM : env.MAIN_BRANCH_CCLD} --grep='CCLDASH-' --format='%H %s'",
                        returnStdout: true
                    ).trim().split("\n")

                    if (commits[0] != "") {
                        def changelog = "Changelog para release ${params.NEW_VERSION}\n\n"
                        commits.each { entry ->
                            def entryTokens = entry.tokenize(" ") // Renamed from 'tokens' to 'entryTokens'
                            def sha = entryTokens[0]
                            def messageParts = entryTokens[1..-1]
                            def message = messageParts.join(" ")

                            changelog += "- ${message}\n"

                            if (patch > 0) {
                                try {
                                    echo "\u001B[32m✔️ Cherry-pick do commit ${sha}\u001B[0m"
                                    sh "git cherry-pick ${sha}"
                                } catch (Exception e) {
                                    echo "\u001B[31m❌ Conflito encontrado no cherry-pick do commit ${sha}. Abortando...\u001B[0m"
                                    sh "git cherry-pick --abort"
                                    error("Cherry-pick falhou. Ajuste manualmente.")
                                }
                            }
                        }

                        writeFile file: env.CHANGELOG_FILE, text: changelog
                        sh "git add ${env.CHANGELOG_FILE}"
                        sh "git commit -m 'docs: adiciona changelog da release ${params.NEW_VERSION}'"
                        echo "\u001B[32m✔️ Changelog gerado e commitado\u001B[0m"
                    } else {
                        echo "\u001B[33m⚠️ Nenhum commit CCLDASH- encontrado para gerar changelog\u001B[0m"
                    }
                }
            }
        } */

        /* stage('Atualizar versão no gradle.properties') {
            steps {
                script {
                    echo "\u001B[34m=== Atualizando versão no gradle.properties ===\u001B[0m"
                    sh '''
                        sed -i "s/^version=.*//* version=${NEW_VERSION}/" gradle.properties
                        git add gradle.properties
                        git commit -m "chore: bump version to ${NEW_VERSION}"
                    '''
                    echo "\u001B[32m✔️ Versão atualizada no gradle.properties\u001B[0m"
                }
            }
        } */

        /* stage('Push nova branch de release') {
            when {
                expression { return env.BRANCH_NAME }
            }
            steps {
                withCredentials([usernamePassword(credentialsId: 'github-pat',
                                          usernameVariable: 'GIT_USERNAME',
                                          passwordVariable: 'GIT_PASSWORD')]) {
                    sh """
                        git config --global credential.helper cache
                        git remote set-url origin https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/gersondeveloper/ccld.git
                        git push origin ${env.BRANCH_NAME}
                    """
                }
                echo "\u001B[32m✔️ Branch ${env.BRANCH_NAME} enviada ao repositório\u001B[0m"
            }
        } */

       /*  stage('Criar e Push da Tag') {
                steps {
                    script {
                        echo "\u001B[34m=== Criando e enviando a Tag da versão fechada ===\u001B[0m"
                        def versionToTag = (params.PROJECT == 'CCLD') ? env.CCLD_CLOSED_VERSION :
                                           (params.PROJECT == 'CCLM') ? env.CCLM_CLOSED_VERSION :
                                           env.CCLD_CLOSED_VERSION
                        withCredentials([usernamePassword(credentialsId: 'github-pat',
                          usernameVariable: 'GIT_USERNAME',
                          passwordVariable: 'GIT_PASSWORD')]){
                            sh """
                                git tag ${versionToTag}
                                git push origin ${versionToTag}
                            """
                        }
                        echo "\u001B[32m✔️ Tag ${versionToTag} criada e enviada\u001B[0m"
                    }
                }
            }
        }*/
    }

    post {
        success {
            script {
                def totalTime = (System.currentTimeMillis() - START_TIME.toLong()) / 60000
                echo "\u001B[32m🏁 Pipeline finalizada com sucesso em ${totalTime} minutos.\u001B[0m"
            }
        }
        failure {
            echo "\u001B[31m❌ Pipeline falhou!\\u001B[0m"
        }
    }
}


def closeCCLDVersion(productVersion) {
    echo "\u001B[34m=== Fechando versão para o projeto CCLD ===\u001B[0m"
    sh '''
        if [ ! -f gradle.properties ]; then
            echo "gradle.properties não encontrado. Copiando exemplo."
            cp gradle.properties.example gradle.properties
        fi
        ./gradlew setProductVersion -PproductVersion='${productVersion}'
    '''

    def changes = sh(
        script: "git status --porcelain | grep 'build.gradle'",
        returnStatus: true
    )

    if (changes == 0) {
        echo "\u001B[34m=== Alterações detectadas no build.gradle ===\u001B[0m"

        // Obter a nova versão do gradle.properties
        def newVersion = sh(
            script: "grep '^version=' gradle.properties | cut -d'=' -f2",
            returnStdout: true
        ).trim()

        sh '''
            git add build.gradle
            git commit -m "Versão do produto fechada para ${newVersion}"
        '''
        echo "\u001B[32m✔️ Alterações no build.gradle commitadas com sucesso\u001B[0m"
    } else {
        echo "\u001B[33m⚠️ Nenhuma alteração detectada no build.gradle\u001B[0m"
    }

    echo "\u001B[32m✔️ Versão do CCLD fechada e alterada\u001B[0m"
    env.CCLD_CLOSED_VERSION = productVersion
}

def closeCCLMVersion(productVersion, lastCcldVersion) {
    echo "\u001B[34m=== Fechando versão para o projeto CCLM ===\u001B[0m"
    sh """
        cd cc-messaging
        currentCcldVersion=\$(xmllint --xpath "//*[local-name()='dependency'][*[local-name()='artifactId']='ccld-artifact']/version/text()" pom.xml || echo '')
        echo "Versão atual da dependência CCLD: \$currentCcldVersion"
        echo "Última tag do CCLD detectada: ${lastCcldVersion}"

        if [ "\$currentCcldVersion" != "${lastCcldVersion}" ] && [ ! -z "\$currentCcldVersion" ]; then
            echo "Atualizando versão da dependência CCLD no pom.xml..."
            mvn versions:set-property -Dproperty=ccld.version -DnewVersion=${lastCcldVersion} -DgenerateBackupPoms=false
            git add pom.xml
            git commit -m "chore: update CCLD dependency to version ${lastCcldVersion}"
        fi

        echo "Atualizando versão principal do CCLM..."
        mvn versions:set -DremoveSnapshot -DgenerateBackupPoms=false
        mvn clean install -DskipTests
        git add .
        git commit -m "Artifact version ${productVersion} closed for product version ${productVersion}"
        git push origin ${MAIN_BRANCH_CCLM}
    """
    echo "\u001B[32m✔️ Versão do CCLM fechada com sucesso\u001B[0m"
    env.CCLM_CLOSED_VERSION = productVersion
}