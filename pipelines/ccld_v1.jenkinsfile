pipeline {
    agent any

    parameters {
        choice(name: 'PROJECT', choices: ['CCLD', 'CCLM', 'ALL'], description: 'Projeto para gerar release')
        string(name: 'NEW_VERSION', defaultValue: '1.2.1', description: 'Nova vers√£o a ser gerada (ex: 1.2.1)')
    }

    environment {
        CCLD_REPOSITORY = '{enderecoRepositorioCCLD}'
        CCLM_REPOSITORY = '{enderecoRepositorioCCLM}'

        MAIN_BRANCH_CCLD = 'master'
        MAIN_BRANCH_CCLM = 'main'

        CCLD_CLOSED_VERSION = ''
        CCLM_CLOSED_VERSION = ''

        CHANGELOG_FILE = "CHANGELOG-${params.NEW_VERSION}.txt"
        START_TIME = ""
    }

    stages {
        stage('Init') {
            steps {
                script {
                    env.START_TIME = System.currentTimeMillis()
                    echo "\u001B[34m====================== Iniciando Pipeline de Release ======================\\u001B[0m"
                }
            }
        }

        stage('Clean Workspace') {
            steps {
                deleteDir()
                echo "\u001B[32m‚úîÔ∏è Workspace limpo com sucesso\u001B[0m"
            }
        }

        stage('Fetch Code') {
            parallel {
                stage('Fetch CCLD') {
                    when { anyOf { expression { params.PROJECT == 'CCLD' }; expression { params.PROJECT == 'ALL' } } }
                    steps {
                        script {
                            echo "\u001B[34m=== Fetching CCLD Repository ===\u001B[0m"
                            checkout([$class: 'GitSCM', branches: [[name: "*/${env.MAIN_BRANCH_CCLD}"]], userRemoteConfigs: [[url: env.CCLD_REPOSITORY]]])
                            echo "\u001B[32m‚úîÔ∏è CCLD repository fetch conclu√≠do\u001B[0m"
                        }
                    }
                }
                stage('Fetch CCLM') {
                    when { anyOf { expression { params.PROJECT == 'CCLM' }; expression { params.PROJECT == 'ALL' } } }
                    steps {
                        script {
                            echo "\u001B[34m=== Fetching CCLM Repository ===\u001B[0m"
                            checkout([$class: 'GitSCM', branches: [[name: "*/${env.MAIN_BRANCH_CCLM}"]], userRemoteConfigs: [[url: env.CCLM_REPOSITORY]]])
                            echo "\u001B[32m‚úîÔ∏è CCLM repository fetch conclu√≠do\u001B[0m"
                        }
                    }
                }
            }
        }

        stage('Detectar √öltima Tag') {
            steps {
                script {
                    echo "\u001B[34m=== Detectando √∫ltima tag ===\u001B[0m"
                    env.LAST_TAG = sh(
                        script: '''
                            git fetch --tags
                            git tag --sort=-creatordate | grep -E '^[0-9]+\\.[0-9]+\\.[0-9]+$' | head -n 1
                        ''',
                        returnStdout: true
                    ).trim()
                    echo "\u001B[32m‚úîÔ∏è √öltima tag detectada: ${env.LAST_TAG}\u001B[0m"
                }
            }
        }

        stage('Close Current Version') {
            steps {
                script {
                    echo "\u001B[34m=== Fechando a vers√£o atual ===\u001B[0m"
                    if (params.PROJECT == 'CCLD' || params.PROJECT == 'ALL') {
                        closeCCLDVersion(params.NEW_VERSION)
                    }
                    if (params.PROJECT == 'CCLM' || params.PROJECT == 'ALL') {
                        closeCCLMVersion(params.NEW_VERSION, env.LAST_TAG)
                    }
                    echo "\u001B[32m‚úîÔ∏è Vers√£o fechada com sucesso\u001B[0m"
                }
            }
        }

        stage('Criar nova branch de release') {
            steps {
                script {
                    echo "\u001B[34m=== Criando nova branch de release ===\u001B[0m"
                    env.BRANCH_NAME = "release/${params.NEW_VERSION}"
                    sh "git checkout -b ${env.BRANCH_NAME}"
                    echo "\u001B[32m‚úîÔ∏è Branch ${env.BRANCH_NAME} criada\u001B[0m"
                }
            }
        }

        stage('Gerar Changelog e Cherry-pick se necess√°rio') {
            steps {
                script {
                    echo "\u001B[34m=== Gerando changelog e realizando cherry-pick se necess√°rio ===\u001B[0m"
                    def (major, minor, patch) = params.NEW_VERSION.tokenize('.')*.toInteger()
                    def commits = sh(
                        script: "git log ${env.LAST_TAG}..origin/${params.PROJECT == 'CCLM' ? env.MAIN_BRANCH_CCLM : env.MAIN_BRANCH_CCLD} --grep='CCLDASH-' --format='%H %s'",
                        returnStdout: true
                    ).trim().split("\n")

                    if (commits[0] != "") {
                        def changelog = "Changelog para release ${params.NEW_VERSION}\n\n"
                        commits.each { entry ->
                            def (sha, *messageParts) = entry.tokenize(" ")
                            def message = messageParts.join(" ")

                            changelog += "- ${message}\n"

                            if (patch > 0) {
                                try {
                                    echo "\u001B[32m‚úîÔ∏è Cherry-pick do commit ${sha}\u001B[0m"
                                    sh "git cherry-pick ${sha}"
                                } catch (Exception e) {
                                    echo "\u001B[31m‚ùå Conflito encontrado no cherry-pick do commit ${sha}. Abortando...\u001B[0m"
                                    sh "git cherry-pick --abort"
                                    error("Cherry-pick falhou. Ajuste manualmente.")
                                }
                            }
                        }

                        writeFile file: env.CHANGELOG_FILE, text: changelog
                        sh "git add ${env.CHANGELOG_FILE}"
                        sh "git commit -m 'docs: adiciona changelog da release ${params.NEW_VERSION}'"
                        echo "\u001B[32m‚úîÔ∏è Changelog gerado e commitado\u001B[0m"
                    } else {
                        echo "\u001B[33m‚ö†Ô∏è Nenhum commit CCLDASH- encontrado para gerar changelog\u001B[0m"
                    }
                }
            }
        }

        stage('Atualizar vers√£o no gradle.properties') {
            steps {
                script {
                    echo "\u001B[34m=== Atualizando vers√£o no gradle.properties ===\u001B[0m"
                    sh '''
                        sed -i "s/^version=.*/version=${NEW_VERSION}/" gradle.properties
                        git add gradle.properties
                        git commit -m "chore: bump version to ${NEW_VERSION}"
                    '''
                    echo "\u001B[32m‚úîÔ∏è Vers√£o atualizada no gradle.properties\u001B[0m"
                }
            }
        }

        stage('Push nova branch de release') {
            steps {
                sh '''
                    git config user.name "jenkins-bot"
                    git config user.email "jenkins@yourcompany.com"
                    git push origin ${BRANCH_NAME}
                '''
                echo "\u001B[32m‚úîÔ∏è Branch ${env.BRANCH_NAME} enviada ao reposit√≥rio\u001B[0m"
            }
        }

        stage('Criar e Push da Tag') {
            steps {
                sh '''
                    git tag ${NEW_VERSION}
                    git push origin ${NEW_VERSION}
                '''
                echo "\u001B[32m‚úîÔ∏è Tag ${params.NEW_VERSION} criada e enviada\u001B[0m"
            }
        }
    }

    post {
        success {
            script {
                def totalTime = (System.currentTimeMillis() - START_TIME.toLong()) / 60000
                echo "\u001B[32müèÅ Pipeline finalizada com sucesso em ${totalTime} minutos.\u001B[0m"
            }
        }
        failure {
            echo "\u001B[31m‚ùå Pipeline falhou!\\u001B[0m"
        }
    }
}

// Fun√ß√µes auxiliares

def closeCCLDVersion(productVersion) {
    echo "\u001B[34m=== Fechando vers√£o para o projeto CCLD ===\u001B[0m"
    sh '''
        ./gradlew setProductVersion -PproductVersion='${productVersion}'
        cd ccl-dashboard/frontend
        changes=$(git diff --name-only src/environments.model.ts)
        if [ ! -z "$changes" ]; then
            git add src/environments/environment.model.ts
            git commit -m "Product version ${productVersion}.0 opened"
            git push origin master
        fi
    '''
    echo "\u001B[32m‚úîÔ∏è Vers√£o do CCLD fechada e alterada no frontend\u001B[0m"
}

def closeCCLMVersion(productVersion, lastCcldVersion) {
    echo "\u001B[34m=== Fechando vers√£o para o projeto CCLM ===\u001B[0m"
    sh """
        cd cc-messaging
        currentCcldVersion=\$(xmllint --xpath "//*[local-name()='dependency'][*[local-name()='artifactId']='ccld-artifact']/version/text()" pom.xml || echo '')
        echo "Vers√£o atual da depend√™ncia CCLD: \$currentCcldVersion"
        echo "√öltima tag do CCLD detectada: ${lastCcldVersion}"
        
        if [ "\$currentCcldVersion" != "${lastCcldVersion}" ] && [ ! -z "\$currentCcldVersion" ]; then
            echo "Atualizando vers√£o da depend√™ncia CCLD no pom.xml..."
            mvn versions:set-property -Dproperty=ccld.version -DnewVersion=${lastCcldVersion} -DgenerateBackupPoms=false
            git add pom.xml
            git commit -m "chore: update CCLD dependency to version ${lastCcldVersion}"
        fi

        echo "Atualizando vers√£o principal do CCLM..."
        mvn versions:set -DremoveSnapshot -DgenerateBackupPoms=false
        mvn clean install -DskipTests
        git add .
        git commit -m "Artifact version ${productVersion} closed for product version ${productVersion}"
        git push origin ${MAIN_BRANCH_CCLM}
    """
    echo "\u001B[32m‚úîÔ∏è Vers√£o do CCLM fechada com sucesso\u001B[0m"
}